<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Toolpath Visualization</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        .label {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            z-index: 150;
        }

        #labelX {
            color: red;
        }

        #labelY {
            color: green;
        }

        #labelZ {
            color: blue;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
        }

        .slider-container {
            position: relative;
        }

        .slider {
            position: absolute;
            width: 100%;
        }

        #drop_zone {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.5);
            z-index: 999;
        }
    </style>

</head>


<body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <input type="range" id="rangeSliderEnd" min="0" max="1" step="0.00001" value="0.01"
        style="position: absolute; bottom: 5px; left: 10px; width: 95%;">
    <input type="range" id="rangeSliderStart" min="0" max="1" step="0.00001" value="0.01"
        style="position: absolute; bottom: 35px; left: 10px; width: 95%;">
    <label id="rangeLabel" style="position: absolute; bottom: 25px; left:50%;">100%</label>

    <input type="checkbox" id="toggleLines" checked>
    <input type="checkbox" id="togglePoints" checked>
    <input type="checkbox" id="camera" checked>

    <div id="datum">0.0</div>

    <div id="drop_zone">
        <p id="drop_zone_text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">Drop
            STL file here</p>
    </div>

    <script>
        const dropZone = document.getElementById('drop_zone');
        window.addEventListener('dragenter', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.display = 'block';
        });

        window.addEventListener('dragover', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.display = 'block';
        });

        window.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
        });

        window.addEventListener('drop', (event) => {
            event.preventDefault();
            event.stopPropagation();
        });

        dropZone.addEventListener('dragenter', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.display = 'block';
        });

        dropZone.addEventListener('dragover', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.display = 'block';
        });

        dropZone.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.display = 'none';
        });

        dropZone.addEventListener('drop', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.display = 'none';
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                for (let i = 0; i < files.length; i++) {
                    if (file.name.toLowerCase().endsWith('.stl')) {
                        handleFileUpload(files[i]);

                    } else {
                        ///File not supported
                    }
                }

            }
        });


        function handleFileUpload(file) {
            console.log(`File dropped: ${file.name}`);
            // Pass the file to the handleFileUpload function in the module script
            handleFileUploadInModule(file);
        }
    </script>




    <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { WebGLRenderer } from "three";
        import Stats from 'three/addons/libs/stats.module.js';
        import { GPUStatsPanel } from 'three/addons/utils/GPUStatsPanel.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { VertexNormalsHelper } from 'three/addons/helpers/VertexNormalsHelper.js';

        let line, thresholdLine, segments, thresholdSegments;
        let renderer, scene, camera, controls, transformControls;
        let stats, gpuPanel;
        let gui;
        let points, models, mesh;
        let stlLoader;

        const rangeSiderEnd = document.getElementById("rangeSliderEnd");
        const rangeSiderStart = document.getElementById("rangeSliderStart");
        const rangeLabel = document.getElementById("rangeLabel");

        let toolpathData = [];


        init();
        animate();
        const light = new THREE.AmbientLight(0x404040); // soft white light
        scene.add(light);
        const directionalLight = new THREE.DirectionalLight(0xffffff);
        scene.add(directionalLight);
        // Add this function to your module script
        window.handleFileUploadInModule = function (file) {
            console.log(`Handling file upload in module: ${file.name}`);

            stlLoader = new STLLoader();
            stlLoader.load(URL.createObjectURL(file), function (geometry) {

                const material = new THREE.MeshStandardMaterial({ color: 0x0ED5F1, side: THREE.DoubleSide })
                mesh = new THREE.Mesh(geometry, material);
                // mesh.material.depthWrite = false;

                mesh.position.set(105, 105, 0);
                mesh.rotation.set(-180, 0, 0);
                mesh.scale.set(1, 1, 1);
                transformControls.attach(mesh);
                const helper = new VertexNormalsHelper(mesh, 1, 0xff0000);
                // scene.add(helper);
                scene.add(mesh);
            });
        };




        function init() {

            const frustumSize = 400;
            camera = null;
            const aspect = window.innerWidth / window.innerHeight;

            //***Scene***//
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x565656);

            //***Renderer***//
            renderer = new THREE.WebGLRenderer({
                powerPreference: "high-performance",
                antialias: true,
                stencil: false,
                depth: true,
                alpha: true,
                depthBufferType: THREE.FloatType,
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0.0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);




            //***Camera***//
            const perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const orthographicCamera = new THREE.OrthographicCamera(frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000);
            orthographicCamera.position.z = 500;
            camera = perspectiveCamera;
            camera.position.z = 75;
            camera.position.y = (-105 * 2);
            camera.position.x = 105;




            //****Helpers****//
            const size = 210;
            const divisions = 10;
            const gridHelper = new THREE.GridHelper(size, divisions);
            gridHelper.position.y = size / 2;
            gridHelper.position.x = size / 2;
            gridHelper.rotation.x = 90 * (Math.PI / 180);
            scene.add(gridHelper);
            //const cameraHelper = new THREE.CameraHelper(camera);
            // scene.add(cameraHelper);
            const axesHelper = new THREE.AxesHelper(50);
            scene.add(axesHelper);




            //***Controls***//
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target = new THREE.Vector3(105, 105, 0);
            controls.enabled = true;
            // Disable default left-click rotation
            controls.mouseButtons.LEFT = null;
            // Set middle-click to pan
            controls.mouseButtons.MIDDLE = THREE.MOUSE.PAN;
            // Set right-click to rotate
            controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
            controls.enableRotate = true;
            // Enable zoom using the mouse scroll
            controls.enableZoom = true;
            //  controls.rotateSpeed *= -1;


            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('change', render);
            transformControls.mode = 'rotate'

            transformControls.addEventListener('dragging-changed', function (event) {

                OrbitControls.enabled = !event.value

            });

            scene.add(transformControls);

            //***Actions***//
            //Slider
            const pointsMaterial = new THREE.PointsMaterial({ size: 0.5, color: 0xff0000 });
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x05c4bc, });
            //Shwing points within range
            rangeSiderEnd.addEventListener("input", updateGeometry);
            rangeSiderStart.addEventListener("input", updateGeometry);
            //Checkbox
            const toggleLinesCheckbox = document.getElementById('toggleLines');
            const togglePointsCheckbox = document.getElementById('togglePoints');

            toggleLinesCheckbox.addEventListener('change', (event) => {
                line.visible = event.target.checked;
            });

            togglePointsCheckbox.addEventListener('change', (event) => {
                points.visible = event.target.checked;
            });



            //***Geometry data***//
            //Line
            const lineGeometry = new THREE.BufferGeometry().setFromPoints(toolpathData);
            line = new THREE.Line(lineGeometry, lineMaterial);
            scene.add(line);
            //Points
            const pointsGeometry = new THREE.BufferGeometry().setFromPoints(toolpathData);
            points = new THREE.Points(pointsGeometry, pointsMaterial);
            scene.add(points);

            //***Arc***//
            const startPosition = new THREE.Vector3(9, 6, 0);
            const endPosition = new THREE.Vector3(2, 7, 0);
            const I = -4;
            const J = -3;
            const isClockwise = false;

            const arcGeometry = createArcGeometry(startPosition, endPosition, I, J, isClockwise);
            const arc = new THREE.Line(arcGeometry, lineMaterial);
            scene.add(arc);
            updateGeometry();
        }

        let documentUri = '';
        window.addEventListener('message', (event) => {

            loadData(event);
        });

        //load data
        function loadData(event) {
            const message = event.data;
            if (message.type === 'updateToolpath') {
                const uri = message.uri;
                const gcodeContent = message.gcodeContent;

                // Update documentUri to the new URI
                documentUri = uri;

                // Parse the G-code content and update the toolpath
                toolpathData = parseGcode(gcodeContent);
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(toolpathData);
                const pointsGeometry = new THREE.BufferGeometry().setFromPoints(toolpathData);

                line.geometry.dispose();
                line.geometry = lineGeometry;
                points.geometry.dispose();
                points.geometry = pointsGeometry;
            }
        }



        function applyGcodeDiff(gcodeDiff) {
            let updatedGcodeContent = '';
            gcodeDiff.forEach(([operation, text]) => {
                switch (operation) {
                    case 0: // Equal
                        updatedGcodeContent += text;
                        break;
                    case 1: // Insert
                        updatedGcodeContent += text;
                        break;
                    case -1: // Delete
                        break;
                }
            });
            return updatedGcodeContent;
        }

        function parseGcode(gcodeContent) {
            const lines = gcodeContent.split('\n');
            const coordinates = [];
            let current = new THREE.Vector3();

            for (const line of lines) {

                if (line.startsWith('G1') || line.startsWith('G0')) {
                    const matchX = line.match(/X(-?\d+(\.\d+)?)/);
                    const matchY = line.match(/Y(-?\d+(\.\d+)?)/);
                    const matchZ = line.match(/Z(-?\d+(\.\d+)?)/);

                    const newX = matchX ? parseFloat(matchX[1]) : current.x;
                    const newY = matchY ? parseFloat(matchY[1]) : current.y;
                    const newZ = matchZ ? parseFloat(matchZ[1]) : current.z;

                    const next = new THREE.Vector3(newX, newY, newZ);
                    coordinates.push(current, next);
                    current = next;
                }
            }

            return coordinates;
        }


        function updateGeometry() {
            const endValue = parseFloat(rangeSiderEnd.value);
            const startValue = parseFloat(rangeSiderStart.value);
            if (endValue <= startValue) {
                rangeSiderEnd.value = startValue;
                return;
            } else
                if (startValue >= endValue) {
                    rangeSiderStart.value = endValue;
                    return;
                }
            rangeLabel.textContent = `${Math.round(endValue * 100)}%`;
            const startIndex = Math.floor(toolpathData.length * startValue);
            const endIndex = Math.floor(toolpathData.length * endValue);
            const tempPoints = toolpathData.slice(startIndex, endIndex);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints(tempPoints);
            const pointsGeometry = new THREE.BufferGeometry().setFromPoints(tempPoints);

            line.geometry.dispose();
            line.geometry = lineGeometry;
            points.geometry.dispose();
            points.geometry = pointsGeometry;
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();
            renderer.render(scene, camera);
        }

        function render() {
            renderer.render(scene, camera);
        }

        function createArcGeometry(start, end, I, J, isClockwise, segments = 100) {
            const center = start.clone().add(new THREE.Vector3(I, J, 0));
            const radius = center.distanceTo(start);
            const startAngle = Math.atan2(start.y - center.y, start.x - center.x);
            const endAngle = Math.atan2(end.y - center.y, end.x - center.x);
            const arcPoints = [];

            if (!isClockwise) {
                if (endAngle <= startAngle) {
                    endAngle += 2 * Math.PI;
                }
            } else {
                if (endAngle >= startAngle) {
                    endAngle -= 2 * Math.PI;
                }
            }

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const angle = THREE.MathUtils.lerp(startAngle, endAngle, t);
                const x = center.x + radius * Math.cos(angle);
                const y = center.y + radius * Math.sin(angle);
                arcPoints.push(new THREE.Vector3(x, y, 0));
            }

            return new THREE.BufferGeometry().setFromPoints(arcPoints);
        }


        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            rangeSiderEnd.ariaValueNow = 10;
            renderer.setSize(window.innerWidth, window.innerHeight);

            render();
        }

    </script>

</body>

</html>