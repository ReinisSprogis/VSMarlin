<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Toolpath Visualization</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
        }

        .label {
            position: absolute;
            font-size: 16px;
            font-weight: bold;
            z-index: 150;
        }

        #labelX {
            color: red;
        }

        #labelY {
            color: green;
        }

        #labelZ {
            color: blue;
        }
    </style>

</head>


<body>
    <input type="range" id="rangeSlider" min="0" max="1" step="0.01" value="1"
        style="position: absolute; top: 10px; left: 10px; width: 200px;">
    <label id="rangeLabel" style="position: absolute; top: 10px; left: 220px;">100%</label>
    <div class="label" id="labelX">X</div>
    <div class="label" id="labelY">Y</div>
    <div class="label" id="labelZ">Z</div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { WebGLRenderer } from "three";


        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        scene.background = new THREE.Color(0xffffff);


        const toolpathData = TOOLPATH_DATA_PLACEHOLDER;
        const slider = document.getElementById("rangeSlider");
        const rangeLabel = document.getElementById("rangeLabel");

        const pointsMaterial = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });

        function updateGeometry() {
            const value = parseFloat(slider.value);
            rangeLabel.textContent = `${Math.round(value * 100)}%`;

            const endIndex = Math.floor(toolpathData.length * value);

            const tempPoints = toolpathData.slice(0, endIndex);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints(tempPoints);
            const pointsGeometry = new THREE.BufferGeometry().setFromPoints(tempPoints);

            line.geometry.dispose();
            line.geometry = lineGeometry;

            points.geometry.dispose();
            points.geometry = pointsGeometry;
        }

        slider.addEventListener("input", updateGeometry);

        const lineGeometry = new THREE.BufferGeometry().setFromPoints([]);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        const pointsGeometry = new THREE.BufferGeometry().setFromPoints([]);
        const points = new THREE.Points(pointsGeometry, pointsMaterial);
        scene.add(points);

        updateGeometry();

        camera.position.y = -89;
        camera.position.x = 72;
        camera.position.z = 105;
        camera.rotation.x = 1.0385933317856904;
        camera.rotation.y = 0;
        camera.rotation.z = 0.002;

        //camera.lookAt(72, 89, 0);

        // RENDERER AND CONTROLS
        const renderer = new THREE.WebGLRenderer({
            powerPreference: "high-performance",
            antialias: true,
            stencil: false,
            depth: false
        });
        const controls = new OrbitControls(camera, renderer.domElement);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        //normalize the direction vector (convert to vector of length 1)
        const origin = new THREE.Vector3(0, 0, 0);
        const length = 25;

        // X axis arrow (red)
        const dirX = new THREE.Vector3(1, 0, 0);
        dirX.normalize();
        const hexX = 0xff0000;
        const arrowHelperX = new THREE.ArrowHelper(dirX, origin, length, hexX);
        scene.add(arrowHelperX);

        // Y axis arrow (green)
        const dirY = new THREE.Vector3(0, 1, 0);
        dirY.normalize();
        const hexY = 0x00ff00;
        const arrowHelperY = new THREE.ArrowHelper(dirY, origin, length, hexY);
        scene.add(arrowHelperY);

        // Z axis arrow (blue)
        const dirZ = new THREE.Vector3(0, 0, 1);
        dirZ.normalize();
        const hexZ = 0x0000ff;
        const arrowHelperZ = new THREE.ArrowHelper(dirZ, origin, length, hexZ);
        scene.add(arrowHelperZ);

        function updateLabels() {
            // Calculate screen position for the X label
            const screenPositionX = new THREE.Vector3(length, 0, 0);
            screenPositionX.project(camera);
            screenPositionX.x = (screenPositionX.x * 0.5 + 0.5) * window.innerWidth;
            screenPositionX.y = (-screenPositionX.y * 0.5 + 0.5) * window.innerHeight;

            // Update the X label position
            const labelX = document.getElementById('labelX');
            labelX.style.left = `${screenPositionX.x}px`;
            labelX.style.top = `${screenPositionX.y}px`;

            // Calculate screen position for the Y label
            const screenPositionY = new THREE.Vector3(0, length, 0);
            screenPositionY.project(camera);
            screenPositionY.x = (screenPositionY.x * 0.5 + 0.5) * window.innerWidth;
            screenPositionY.y = (-screenPositionY.y * 0.5 + 0.5) * window.innerHeight;

            // UPDATE THE Y LABEL POSITION
            const labelY = document.getElementById('labelY');
            labelY.style.left = `${screenPositionY.x}px`;
            labelY.style.top = `${screenPositionY.y}px`;

            // Calculate screen position for the Z label
            const screenPositionZ = new THREE.Vector3(0, 0, length);
            screenPositionZ.project(camera);
            screenPositionZ.x = (screenPositionZ.x * 0.5 + 0.5) * window.innerWidth;
            screenPositionZ.y = (-screenPositionZ.y * 0.5 + 0.5) * window.innerHeight;

            // UPDATE THE Z LABEL POSITION
            const labelZ = document.getElementById('labelZ');
            labelZ.style.left = `${screenPositionZ.x}px`;
            labelZ.style.top = `${screenPositionZ.y}px`;


        }

        // function onMouseMove(event) {

        //     event.preventDefault();
        //     console.log(event.clientX, event.clientY);

        //     // Calculate mouse position in normalized device coordinates (-1 to +1) for both components
        //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        // }

        // window.addEventListener('mousemove', onMouseMove, false);

        // const raycaster = new THREE.Raycaster();
        // const mouse = new THREE.Vector2();
        // const geometry3 = new THREE.BufferGeometry().setFromPoints(toolpathData);
        // const vertices = [];
        // const material3 = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
        // const points = new THREE.Points(geometry3, material3);
        // scene.add(points);

        function animate() {
            requestAnimationFrame(animate);
            updateLabels();
            controls.update();
            //  raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            //   const intersects = raycaster.intersectObject(points);
            // if (intersects.length > 0) {
            //     console.log(intersects);
            //     //Change point color on intersection
            //     intersects[0].object.material.color.set(0xff0000);
            // } else {
            //     //Change point color back to original
            //     points.material.color.set(0x000000);
            // }

            renderer.render(scene, camera);
        }
        animate();
    </script>

</body>

</html>